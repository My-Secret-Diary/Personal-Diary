<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>My Secret Diary</title>
  <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@400;600&family=Patrick+Hand&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg-light:#f6f9fc;
      --card:#ffffff;
      --muted:#6b7280;
      --accent:#b5651d;
      --accent-strong:#3b82f6;
      --paper:#fffef6;
      --shadow: 0 8px 30px rgba(16,24,40,0.06);
      --toolbar-active: #3b82f6;
    }
    [data-theme="dark"]{
      --bg-light:#0b0f14;
      --card:#0f1720;
      --muted:#9aa4b2;
      --paper:#0b1215;
      --accent:#b5651d;
      --accent-strong:#60a5fa;
    }
    *{box-sizing:border-box}
    body{
      font-family: 'Quicksand', system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
      background: var(--bg-light);
      margin:0;
      padding:20px;
      display:flex;
      justify-content:center;
      align-items:flex-start;
      min-height:100vh;
      transition:background .2s;
      background-size:cover;
      background-position:center;
    }
    /* Keep login EXACTLY like you had it -- unchanged styling and layout */
    #login, #diary {
      background: var(--card);
      border-radius: 20px;
      box-shadow: var(--shadow);
      padding: 28px;
      width: 820px;
      max-width: 98%;
      transition: 0.3s;
    }
    #login h1, #diary h1 { text-align:center; margin:0 0 10px; font-family: 'Patrick Hand', Georgia, serif; font-size:28px; }
    #login p { text-align:center; color:var(--muted); margin: 8px 0 14px; }
    input[type=password], input[type=date], input[type=file], button, .color-btn {
      font-family: inherit;
      font-size: 15px;
      padding: 10px;
      border-radius: 8px;
      border: 1px solid #ccc;
      outline: none;
      width: 100%;
      margin: 6px 0;
      background: white;
    }
    button { cursor:pointer; background: #4a90e2; color:#fff; border:0; transition:background .14s; }
    button:hover { background:#357abd; }
    #toolbar {
      margin: 12px 0;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .tool {
      background:#f1f3f5;
      border:1px solid #d8dee6;
      padding:8px 10px;
      border-radius:8px;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
    }
    .tool.active { box-shadow:0 2px 10px rgba(59,130,246,0.18); border-color:var(--toolbar-active); color:var(--toolbar-active); }
    .color-btn { width:40px; height:40px; padding:0; border-radius:8px; }
    #editor {
      border:1px solid #dfe6ee;
      border-radius:12px;
      padding:18px;
      background: var(--paper);
      min-height:320px;
      max-height:520px;
      overflow-y:auto;
      font-size:16px;
      line-height:1.6;
      font-family:'Patrick Hand', Georgia, serif;
    }
    #calendar {
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
      margin-bottom:12px;
    }
    #topControls { display:flex; justify-content:space-between; align-items:center; gap:10px; margin-bottom:12px; }
    #rightTopButtons { display:flex; gap:8px; align-items:center; }
    #actionButtons { display:flex; justify-content:flex-end; gap:10px; margin-top:12px; }
    #saveBtn { min-width:120px; }
    .small { color:var(--muted); font-size:13px; }
    .hidden { display:none !important; }

    /* active color highlight for toolbar when selected (blue) */
    .tool.color-active { border-color: var(--toolbar-active); box-shadow: 0 2px 10px rgba(59,130,246,0.18); }
    /* disabled look */
    .disabled { opacity:0.5; pointer-events:none; }

    /* small responsive */
    @media (max-width:860px){
      #login, #diary { padding:14px; width:95%; }
      #editor { min-height:260px; }
    }
  </style>
</head>
<body>
  <!-- LOGIN (kept exactly as user asked) -->
  <div id="login">
    <h1>üîí My Secret Diary</h1>
    <p style="text-align:center;">Enter your diary password</p>
    <input type="password" id="passwordInput" placeholder="Password">
    <button id="loginBtn">Login</button>
  </div>

  <!-- DIARY (hidden until login) -->
  <div id="diary" style="display:none;">
    <div id="topControls">
      <div>
        <h1 id="diaryTitle">My Secret Diary</h1>
        <div class="small" id="subtitle">Private ‚Äî synced & encrypted</div>
      </div>

      <!-- top-right buttons: rename & change password -->
      <div id="rightTopButtons">
        <button id="themeToggle" class="tool" title="Toggle theme">Theme</button>
        <button id="renameBtn" class="tool" title="Rename diary">Rename</button>
        <button id="changePassBtn" class="tool" title="Change password" style="background:#f66;color:#fff;">Password</button>
      </div>
    </div>

    <div id="calendar">
      <input type="date" id="datePicker" />
      <div class="small" id="dateHint">India time</div>
    </div>

    <div id="toolbar">
      <div class="tool" onclick="execCmd('bold')" id="btnBold"><b>B</b></div>
      <div class="tool" onclick="execCmd('italic')" id="btnItalic"><i>I</i></div>
      <div class="tool" onclick="execCmd('underline')" id="btnUnderline"><u>U</u></div>
      <div class="tool" onclick="execCmd('strikeThrough')" id="btnStrike">S</div>

      <!-- Color palette: clicking opens color input -->
      <div class="tool" id="colorTool" title="Text color">
        <span>üé®</span>
        <input type="color" id="colorPicker" class="hidden" />
      </div>

      <div class="tool" id="highlightTool" title="Highlight (background)">üñç Highlight</div>

      <div class="tool" id="uploadBgTool" title="Upload background">
        Background
        <input type="file" id="bgUpload" accept="image/*" class="hidden" />
      </div>

      <div class="tool" id="themeInfo" style="margin-left:auto;" title="Theme info">Theme</div>
    </div>

    <div id="editor" contenteditable="true"></div>

    <div id="actionButtons">
      <button id="saveBtn">üíæ Save</button>
    </div>
  </div>

  <script type="module">
  // ------------------------
  // Encrypted Single-Password Cloud Diary
  // - default password: 53458678
  // - Uses Firestore to store encrypted master key and encrypted entries
  // - Master key (AES-GCM) is encrypted with password-derived key (PBKDF2)
  // - Changing password re-encrypts the master key (entries still encrypted under master key)
  // - Diary metadata (name, background) is encrypted with master key
  // - Login screen remained unchanged
  // ------------------------

  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-app.js";
  import {
    getFirestore, doc, getDoc, setDoc, collection, getDocs, deleteDoc
  } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-firestore.js";

  // --- Paste your Firebase config here (you already provided this) ---
  const firebaseConfig = {
    apiKey: "AIzaSyDRpLl01xtSZ7f0ZbId7zFASUJoem4L69s",
    authDomain: "my-secret-diary-9b62c.firebaseapp.com",
    projectId: "my-secret-diary-9b62c",
    storageBucket: "my-secret-diary-9b62c.firebasestorage.app",
    messagingSenderId: "139353851381",
    appId: "1:139353851381:web:3050a47540d36a2243ccbc"
  };

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // UI elements
  const loginDiv = document.getElementById("login");
  const diaryDiv = document.getElementById("diary");
  const passwordInput = document.getElementById("passwordInput");
  const loginBtn = document.getElementById("loginBtn");
  const diaryTitle = document.getElementById("diaryTitle");
  const datePicker = document.getElementById("datePicker");
  const editor = document.getElementById("editor");
  const saveBtn = document.getElementById("saveBtn");
  const changePassBtn = document.getElementById("changePassBtn");
  const renameBtn = document.getElementById("renameBtn");
  const colorPicker = document.getElementById("colorPicker");
  const colorTool = document.getElementById("colorTool");
  const highlightTool = document.getElementById("highlightTool");
  const bgUpload = document.getElementById("bgUpload");
  const uploadBgTool = document.getElementById("uploadBgTool");
  const themeToggle = document.getElementById("themeToggle");
  const dateHint = document.getElementById("dateHint");

  // constants
  const DEFAULT_PASSWORD = "53458678";
  const SETTINGS_DOC = doc(db, "diary", "main"); // single document for settings (salt, encMaster, encMeta)
  const ENTRIES_COLLECTION = (date) => doc(db, "diary", "entries-" + date); // each day's doc path: diary/entries-YYYY-MM-DD (simple)

  // crypto helpers
  function toB64(arrayBuffer) { return btoa(String.fromCharCode(...new Uint8Array(arrayBuffer))); }
  function fromB64(b64) { return Uint8Array.from(atob(b64), c => c.charCodeAt(0)).buffer; }
  function strToAb(str){ return new TextEncoder().encode(str); }
  function abToStr(ab){ return new TextDecoder().decode(ab); }

  async function genSalt(){ const s = crypto.getRandomValues(new Uint8Array(16)); return s.buffer; }

  async function deriveKeyFromPassword(password, salt) {
    const pwKey = await crypto.subtle.importKey('raw', strToAb(password), 'PBKDF2', false, ['deriveKey']);
    const key = await crypto.subtle.deriveKey(
      { name: 'PBKDF2', salt: salt, iterations: 150000, hash: 'SHA-256' },
      pwKey,
      { name: 'AES-GCM', length: 256 },
      false,
      ['encrypt','decrypt']
    );
    return key;
  }

  async function generateMasterKeyRaw() {
    const key = await crypto.subtle.generateKey({ name:'AES-GCM', length:256 }, true, ['encrypt','decrypt','wrapKey','unwrapKey']);
    const raw = await crypto.subtle.exportKey('raw', key);
    return raw; // ArrayBuffer
  }

  async function importMasterKey(raw) {
    return await crypto.subtle.importKey('raw', raw, 'AES-GCM', true, ['encrypt','decrypt']);
  }

  async function encryptWithKey(key, plaintext) {
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const ct = await crypto.subtle.encrypt({ name:'AES-GCM', iv }, key, strToAb(plaintext));
    return { iv: toB64(iv.buffer), data: toB64(ct) };
  }
  async function decryptWithKey(key, iv_b64, data_b64) {
    try {
      const iv = fromB64(iv_b64);
      const ct = fromB64(data_b64);
      const pt = await crypto.subtle.decrypt({ name:'AES-GCM', iv: new Uint8Array(iv) }, key, ct);
      return abToStr(pt);
    } catch(e){
      throw new Error('Decryption failed');
    }
  }

  // encrypt raw masterKey with password-derived key (we treat masterKey raw bytes as plaintext)
  async function encryptMasterKeyRaw(passwordKey, masterRaw){
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const ct = await crypto.subtle.encrypt({name:'AES-GCM', iv}, passwordKey, masterRaw);
    return { iv: toB64(iv.buffer), data: toB64(ct) };
  }
  async function decryptMasterKeyRaw(passwordKey, iv_b64, data_b64){
    try{
      const iv = fromB64(iv_b64);
      const ct = fromB64(data_b64);
      const raw = await crypto.subtle.decrypt({name:'AES-GCM', iv: new Uint8Array(iv)}, passwordKey, ct);
      return raw;
    }catch(e){ throw new Error('Invalid password or corrupted data');}
  }

  // --------- SETTINGS bootstrap & load ----------
  // settings doc structure:
  // {
  //   salt: <base64>,            // salt used for PBKDF2
  //   encMaster: { iv, data },   // masterKey encrypted with password-derived key
  //   encMeta: { iv, data }      // JSON stringified metadata encrypted with masterKey. metadata = { diaryName, background?: {iv,data} }
  // }

  async function fetchSettingsDoc(){
    try{
      const sdoc = await getDoc(SETTINGS_DOC);
      return sdoc.exists() ? sdoc.data() : null;
    }catch(e){ console.error('fetchSettingsDoc', e); return null; }
  }

  // Create settings doc if not exist ‚Äî uses DEFAULT_PASSWORD to secure master key on bootstrap.
  async function bootstrapSettingsIfMissing(){
    const s = await fetchSettingsDoc();
    if(s) return s;
    // create
    const salt = await genSalt();
    const pwKey = await deriveKeyFromPassword(DEFAULT_PASSWORD, salt);
    const masterRaw = await generateMasterKeyRaw(); // ArrayBuffer raw key
    const encMaster = await encryptMasterKeyRaw(pwKey, masterRaw);
    // metadata (encrypted under master key)
    const masterKeyImported = await importMasterKey(masterRaw);
    const meta = { diaryName: "My Secret Diary" };
    const encMeta = await encryptWithKey(masterKeyImported, JSON.stringify(meta));
    // write to firestore
    await setDoc(SETTINGS_DOC, {
      salt: toB64(salt),
      encMaster,
      encMeta
    });
    return { salt: toB64(salt), encMaster, encMeta };
  }

  // ---------- Login flow ----------
  let sessionMasterKey = null; // CryptoKey for AES-GCM (master), available only after successful password
  let metaCache = null; // decrypted metadata (diaryName, background ciphertext etc)

  // load or create settings on load
  await bootstrapSettingsIfMissing();

  // keep login UI exactly the same; handle click
  loginBtn.addEventListener('click', async () => {
    const pw = passwordInput.value || '';
    // fetch settings doc
    const sdoc = await fetchSettingsDoc();
    if(!sdoc) return alert('Settings missing (try reloading).');

    try{
      const salt = fromB64(sdoc.salt);
      const pwKey = await deriveKeyFromPassword(pw, salt);
      // decrypt master raw
      const masterRaw = await decryptMasterKeyRaw(pwKey, sdoc.encMaster.iv, sdoc.encMaster.data);
      sessionMasterKey = await importMasterKey(masterRaw);
      // decrypt metadata
      const metaJson = await decryptWithKey(sessionMasterKey, sdoc.encMeta.iv, sdoc.encMeta.data);
      metaCache = JSON.parse(metaJson);
      diaryTitle.textContent = metaCache.diaryName || 'My Secret Diary';
      // load theme if present
      if(metaCache.theme === 'dark') document.documentElement.setAttribute('data-theme','dark');
      // background
      if(metaCache.background && metaCache.background.data && metaCache.background.iv){
        try{
          const bgData = await decryptWithKey(sessionMasterKey, metaCache.background.iv, metaCache.background.data);
          document.body.style.backgroundImage = `url(${bgData})`;
        }catch(e){ console.warn('bg decrypt failed', e); }
      }
      // success: show diary
      loginDiv.style.display = 'none';
      diaryDiv.style.display = 'block';
      // set IST date
      datePicker.value = todayIST();
      updateDateHint();
      // load today's entry
      await loadEntry();
    } catch(e){
      console.error(e);
      alert('Wrong password or corrupted settings.');
    }
  });

  // --------- Date utilities in India timezone ----------
  function todayIST(){
    // return YYYY-MM-DD for Asia/Kolkata now
    const now = new Date(new Date().toLocaleString('en-US', { timeZone: 'Asia/Kolkata' }));
    const yyyy = now.getFullYear();
    const mm = String(now.getMonth()+1).padStart(2,'0');
    const dd = String(now.getDate()).padStart(2,'0');
    return `${yyyy}-${mm}-${dd}`;
  }
  function isFutureDate(dateStr){
    const today = todayIST();
    return dateStr > today;
  }
  function updateDateHint(){
    dateHint.textContent = 'India time ‚Äî Today: ' + todayIST();
  }

  // ---------- Entries: encrypt/decrypt using sessionMasterKey ----------
  async function loadEntry(){
    const date = datePicker.value || todayIST();
    // disallow future editing
    if(isFutureDate(date)){
      editor.innerHTML = '<div class="small">You cannot write on future dates.</div>';
      editor.setAttribute('contenteditable','false');
      saveBtn.classList.add('disabled');
      return;
    } else {
      editor.setAttribute('contenteditable','true');
      saveBtn.classList.remove('disabled');
    }

    try{
      const docRef = doc(db, 'diary', 'entries-'+date);
      const entryDoc = await getDoc(docRef);
      if(!entryDoc.exists()){
        editor.innerHTML = '';
        return;
      }
      const d = entryDoc.data();
      // decrypt ciphertext with sessionMasterKey
      const plaintext = await decryptWithKey(sessionMasterKey, d.iv, d.cipher);
      editor.innerHTML = plaintext;
    }catch(e){
      console.error('loadEntry', e);
      editor.innerHTML = '';
    }
  }

  datePicker.addEventListener('change', async ()=> {
    updateDateHint();
    await loadEntry();
  });

  async function saveEntry(){
    const date = datePicker.value || todayIST();
    if(isFutureDate(date)){ alert('Cannot save to future dates.'); return; }
    const text = editor.innerHTML || '';
    const enc = await encryptWithKey(sessionMasterKey, text);
    // store enc.data and enc.iv
    try{
      await setDoc(doc(db, 'diary', 'entries-'+date), {
        cipher: enc.data,
        iv: enc.iv,
        lastSavedAt: new Date().toISOString()
      });
      // small UI feedback
      saveBtn.textContent = 'Saved ‚úì';
      setTimeout(()=> saveBtn.textContent = 'üíæ Save', 1200);
    }catch(e){ console.error('save entry', e); alert('Save failed: '+e.message); }
  }

  saveBtn.addEventListener('click', saveEntry);

  // -------- Change password (requires current password implicitly since sessionMasterKey present) ----------
  changePassBtn.addEventListener('click', async () => {
    const newPass = prompt('Enter NEW password (this will become the required password):');
    if(!newPass || !newPass.trim()) return alert('Password not changed.');
    try{
      // fetch settings doc
      const sdoc = await fetchSettingsDoc();
      if(!sdoc) throw new Error('Settings missing');
      // generate new salt and derive new password key
      const newSalt = await genSalt();
      const newPwKey = await deriveKeyFromPassword(newPass, newSalt);
      // export master raw and encrypt with newPwKey
      const rawMaster = await crypto.subtle.exportKey('raw', sessionMasterKey);
      const encMasterNew = await encryptMasterKeyRaw(newPwKey, rawMaster);
      // update metadata (keep same metaCache, encrypt with master key)
      const encMetaNew = await encryptWithKey(sessionMasterKey, JSON.stringify(metaCache));
      // write to settings
      await setDoc(SETTINGS_DOC, {
        salt: toB64(newSalt),
        encMaster: encMasterNew,
        encMeta: encMetaNew
      });
      alert('Password changed. Use the new password next time you open the diary.');
    }catch(e){ console.error(e); alert('Change password failed: '+e.message); }
  });

  // -------- Rename diary (metadata encrypted with master key) ----------
  renameBtn.addEventListener('click', async () => {
    const newName = prompt('Enter new diary name:', metaCache ? metaCache.diaryName : 'My Secret Diary');
    if(!newName || !newName.trim()) return;
    metaCache = metaCache || {};
    metaCache.diaryName = newName.trim();
    diaryTitle.textContent = metaCache.diaryName;
    // encrypt metaCache and save to settings
    try{
      const encMeta = await encryptWithKey(sessionMasterKey, JSON.stringify(metaCache));
      const sdoc = await fetchSettingsDoc();
      await setDoc(SETTINGS_DOC, {
        salt: sdoc.salt,
        encMaster: sdoc.encMaster,
        encMeta
      });
      alert('Diary renamed!');
    }catch(e){ console.error(e); alert('Rename failed: '+e.message); }
  });

  // -------- Color & highlight tools ----------
  function execCmd(command, value = null){
    document.execCommand(command, false, value);
  }

  // color picker: when user selects a color, apply to selected text
  colorTool.addEventListener('click', () => {
    colorPicker.click();
  });
  colorPicker.addEventListener('input', () => {
    const c = colorPicker.value;
    execCmd('foreColor', c);
    // mark button active briefly
    colorTool.classList.add('color-active');
    setTimeout(()=> colorTool.classList.remove('color-active'), 700);
  });

  // highlight tool uses background color application
  highlightTool.addEventListener('click', async () => {
    // toggle active class visually
    highlightTool.classList.toggle('active');
    // ask for color or use default yellow
    const col = prompt('Enter highlight color (name or hex):', '#fff59d');
    if(!col) return;
    execCmd('hiliteColor', col);
    // give visual feedback
    highlightTool.classList.add('color-active');
    setTimeout(()=> highlightTool.classList.remove('color-active'), 700);
  });

  // keep selected toolbar button highlighted if selection style applied
  // basic polling to detect selection style (since execCommand doesn't expose easily)
  setInterval(()=>{
    // check if selection is bold/italic/underline by queryCommandState
    ['bold','italic','underline','strikeThrough'].forEach(cmd=>{
      const el = document.getElementById('btn' + cmd.charAt(0).toUpperCase() + cmd.slice(1));
      if(!el) return;
      try{
        if(document.queryCommandState(cmd)) el.classList.add('active'); else el.classList.remove('active');
      }catch(e){}
    });
  }, 300);

  // -------- Background upload (image encrypted with master key) ----------
  uploadBgTool.addEventListener('click', ()=> bgUpload.click());
  bgUpload.addEventListener('change', async (e) => {
    const f = e.target.files[0];
    if(!f) return;
    if(f.size > 1024*1024*3) { // limit ~3MB
      return alert('Image too large. Keep below ~3MB.');
    }
    const reader = new FileReader();
    reader.onload = async (ev) => {
      const dataUrl = ev.target.result;
      // encrypt dataUrl with master key
      try{
        metaCache = metaCache || {};
        const encBg = await encryptWithKey(sessionMasterKey, dataUrl);
        metaCache.background = encBg;
        const sdoc = await fetchSettingsDoc();
        const encMeta = await encryptWithKey(sessionMasterKey, JSON.stringify(metaCache));
        await setDoc(SETTINGS_DOC, {
          salt: sdoc.salt,
          encMaster: sdoc.encMaster,
          encMeta
        });
        // apply background locally
        document.body.style.backgroundImage = `url(${dataUrl})`;
        alert('Background uploaded and saved (encrypted).');
      }catch(err){ console.error(err); alert('Background save failed: '+err.message); }
    };
    reader.readAsDataURL(f);
  });

  // -------- Theme toggle (light/dark) ----------
  themeToggle.addEventListener('click', async () => {
    const cur = document.documentElement.getAttribute('data-theme');
    const nxt = cur === 'dark' ? null : 'dark';
    if(nxt) document.documentElement.setAttribute('data-theme','dark'); else document.documentElement.removeAttribute('data-theme');
    // save to metaCache and settings encrypted
    metaCache = metaCache || {};
    metaCache.theme = nxt ? 'dark' : 'light';
    try{
      const sdoc = await fetchSettingsDoc();
      const encMeta = await encryptWithKey(sessionMasterKey, JSON.stringify(metaCache));
      await setDoc(SETTINGS_DOC, { salt: sdoc.salt, encMaster: sdoc.encMaster, encMeta });
    }catch(err){ console.warn('theme save failed', err); }
  });

  // keep login Enter key working
  passwordInput.addEventListener('keyup', (e)=> { if(e.key === 'Enter') loginBtn.click(); });

  // initialize date input with IST date
  datePicker.value = todayIST();
  updateDateHint();

  // prevent writing on future date by disabling editor when future
  datePicker.addEventListener('input', ()=>{
    if(isFutureDate(datePicker.value)){
      editor.setAttribute('contenteditable','false');
      editor.innerHTML = '<div class="small">Cannot write in future dates.</div>';
      saveBtn.classList.add('disabled');
    } else {
      editor.setAttribute('contenteditable','true');
      saveBtn.classList.remove('disabled');
      // load entry if session unlocked
    }
  });

  // Done loading module
  console.log('Encrypted diary loaded. Remember: password is required to decrypt your data.');

  // -------------- End of app script --------------

  </script>
</body>
</html>
