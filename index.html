<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>My Secret Diary â€” Encrypted</title>
  <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300;500;700&family=Roboto+Mono&family=Playfair+Display&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg: #f4f7fb;
      --card: #fff;
      --muted: #666;
      --accent: #4a90e2;
      --accent-active: #357abd;
      --btn: #4a90e2;
      --danger: #f66;
      --success: #6c6;
    }
    [data-theme="dark"]{
      --bg:#0f1720; --card:#0b1220; --muted:#aab; --btn:#2563eb; --accent:#60a5fa;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family: 'Quicksand', system-ui, sans-serif;
      background:var(--bg); height:100vh; display:flex; align-items:center; justify-content:center;
      padding:20px;
    }
    .container{
      width:1100px; max-width:100%; height:80vh; display:flex; gap:18px; align-items:stretch;
    }

    /* Left calendar column */
    .left{
      width:260px; background:var(--card); border-radius:14px; padding:14px; box-shadow:0 6px 24px rgba(0,0,0,0.08);
      display:flex; flex-direction:column; gap:12px;
    }
    #calendarLarge { width:100%; height:100%; border-radius:8px; padding:8px; box-shadow:inset 0 0 0 1px rgba(0,0,0,0.04); overflow:auto; }
    #calendarLarge input[type="date"]{ width:100%; padding:10px; border-radius:8px; border:1px solid #ddd}
    .todayLabel{ font-size:12px; color:var(--muted) }

    /* Main diary UI */
    .main{
      flex:1; background:var(--card); border-radius:14px; padding:16px; box-shadow:0 6px 24px rgba(0,0,0,0.08);
      display:flex; flex-direction:column;
    }

    /* Top bar */
    .topbar{ display:flex; align-items:center; justify-content:space-between; gap:12px }
    .title{ font-size:20px; font-weight:700 }
    .top-controls{ display:flex; gap:8px; align-items:center }
    .top-controls button{ padding:8px 10px; border-radius:8px; border:none; cursor:pointer; background:var(--btn); color:white; }
    .top-controls button.alt{ background:var(--danger) }
    .top-controls button.ghost{ background:transparent; color:var(--muted); border:1px solid rgba(0,0,0,0.05) }

    /* editor area */
    .editorWrap{ margin-top:12px; display:flex; gap:12px; flex:1; min-height:0 }
    .toolbar{
      display:flex; gap:8px; padding:8px; border-radius:8px; background:rgba(0,0,0,0.02); align-items:center; flex-wrap:wrap;
    }
    .toolbar button{
      padding:6px 8px; border-radius:8px; border:1px solid rgba(0,0,0,0.06); background:white; cursor:pointer;
    }
    .toolbar button.active{ background:var(--accent); color:white; border-color:transparent }
    .toolbar .color-swatch{ width:20px; height:20px; border-radius:4px; display:inline-block; border:1px solid rgba(0,0,0,0.08); cursor:pointer; }
    .editor{
      flex:1; display:flex; flex-direction:column; gap:8px; min-width:0;
    }
    #entryText{
      flex:1; width:100%; min-height:300px; resize:none; padding:12px; border-radius:10px; border:1px solid #e0e6ef;
      outline:none; font-size:15px; background:transparent;
    }
    .metadata{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; }

    /* bottom-right save area */
    .bottomBar{
      display:flex; justify-content:flex-end; gap:10px; align-items:center; margin-top:8px;
    }
    .saveBtn{
      padding:10px 14px; border-radius:10px; border:none; cursor:pointer; background:var(--btn); color:white;
    }

    /* login card */
    #login{
      width:420px; background:var(--card); border-radius:12px; padding:20px; box-shadow:0 8px 30px rgba(0,0,0,0.08);
      display:flex; flex-direction:column; gap:12px; align-items:stretch;
    }

    label{ font-size:13px; color:var(--muted) }
    select,input{ padding:8px; border-radius:8px; border:1px solid #ddd; }

    /* color palette popup */
    .palette{ position:relative }
    .palettePopup{
      position:absolute; z-index:40; top:38px; left:0; background:var(--card); padding:8px; border-radius:8px; box-shadow:0 10px 30px rgba(0,0,0,0.12);
      display:grid; grid-template-columns: repeat(6,24px); gap:6px;
    }
    .palettePopup .sw{ width:24px; height:24px; border-radius:4px; cursor:pointer; border:1px solid rgba(0,0,0,0.06) }
    /* small helper */
    .muted-small{ font-size:12px; color:var(--muted) }

    /* responsive */
    @media (max-width:980px){
      .container{ flex-direction:column; height:auto }
      .left{ width:100% }
    }
  </style>
</head>
<body data-theme="light">
  <!-- Login -->
  <div id="login" style="display:none;">
    <h2 style="margin:0">ðŸ”’ My Secret Diary</h2>
    <div>
      <label>Diary password</label>
      <input id="passwordInput" type="password" placeholder="Enter diary password" />
    </div>
    <div style="display:flex; gap:8px;">
      <button id="loginBtn">Login</button>
      <button id="newBtn" class="ghost">Create New Diary</button>
    </div>
    <div class="muted-small">Note: The password is used to encrypt your diary locally and is never sent to Firebase. Keep it safe â€” losing it means losing access to entries.</div>
  </div>

  <!-- Main app -->
  <div class="container" id="app" style="display:none;">
    <div class="left">
      <div style="display:flex; justify-content:space-between; align-items:center">
        <strong>Calendar</strong>
        <div class="todayLabel" id="currentDateLabel"></div>
      </div>
      <div id="calendarLarge">
        <input type="date" id="datePicker" />
        <div style="margin-top:10px;">
          <button id="goTodayBtn" style="padding:8px;border-radius:8px;border:1px solid rgba(0,0,0,0.06);cursor:pointer">Go to Today</button>
        </div>
        <div style="margin-top:12px;">
          <small class="muted-small">Tip: You can edit today and any past dates. Future dates are view-only.</small>
        </div>
      </div>
    </div>

    <div class="main">
      <div class="topbar">
        <div>
          <div class="title" id="diaryTitle">My Secret Diary</div>
          <div class="muted-small" id="subtitle">Encrypted â€” local-only key</div>
        </div>
        <div class="top-controls">
          <button id="themeToggle">Toggle Theme</button>
          <button id="changePassBtn" class="alt">Change Password</button>
          <button id="renameBtn" class="alt">Rename Diary</button>
        </div>
      </div>

      <div class="editorWrap">
        <div style="flex:1; display:flex; flex-direction:column;">
          <div class="toolbar" id="toolbar">
            <button data-cmd="bold" id="btnBold" title="Bold">B</button>
            <button data-cmd="italic" id="btnItalic" title="Italic">I</button>
            <button data-cmd="underline" id="btnUnderline" title="Underline">U</button>
            <button data-cmd="highlight" id="btnHighlight" title="Highlight">â˜…</button>

            <div style="display:flex; gap:6px; align-items:center">
              <label class="muted-small">Font</label>
              <select id="fontSelect">
                <option value="Quicksand">Quicksand</option>
                <option value="Playfair Display">Playfair Display</option>
                <option value="Roboto Mono">Roboto Mono</option>
              </select>
            </div>

            <div style="display:flex; gap:6px; align-items:center">
              <label class="muted-small">Size</label>
              <select id="sizeSelect">
                <option value="14">14px</option>
                <option value="16" selected>16px</option>
                <option value="18">18px</option>
                <option value="20">20px</option>
                <option value="22">22px</option>
              </select>
            </div>

            <div class="palette" id="textColorWrap">
              <button id="textColorBtn" title="Text color">A</button>
              <div class="palettePopup" id="textColorPopup" style="display:none; margin-top:6px;">
                <!-- palette swatches inserted by JS -->
              </div>
            </div>

            <div class="palette" id="bgColorWrap">
              <button id="bgColorBtn" title="Highlight color">ðŸ–Œ</button>
              <div class="palettePopup" id="bgColorPopup" style="display:none; margin-top:6px;"></div>
            </div>

            <div style="margin-left:auto; display:flex; gap:8px; align-items:center">
              <label class="muted-small">Background</label>
              <input id="bgInput" placeholder="color or image URL" />
              <button id="bgSaveBtn" style="padding:6px">Apply</button>
              <button id="bgClearBtn" style="padding:6px">Clear</button>
            </div>
          </div>

          <div class="editor">
            <textarea id="entryText" placeholder="Start writing..."></textarea>
            <div class="metadata">
              <div class="muted-small">Selected date: <span id="selectedDateText"></span></div>
              <div class="muted-small" id="editPermission"></div>
            </div>
          </div>

          <div class="bottomBar">
            <div id="status" class="muted-small"></div>
            <button id="saveBtn" class="saveBtn">ðŸ’¾ Save Entry</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Firebase + App JS -->
  <script type="module">
  // --- Firebase imports ---
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-app.js";
  import {
    getFirestore, doc, getDoc, setDoc, serverTimestamp, updateDoc
  } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-firestore.js";

  // --- Firebase config (replace with yours if needed) ---
  const firebaseConfig = {
    apiKey: "AIzaSyDRpLl01xtSZ7f0ZbId7zFASUJoem4L69s",
    authDomain: "my-secret-diary-9b62c.firebaseapp.com",
    projectId: "my-secret-diary-9b62c",
    storageBucket: "my-secret-diary-9b62c.firebasestorage.app",
    messagingSenderId: "139353851381",
    appId: "1:139353851381:web:3050a47540d36a2243ccbc"
  };
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // --- DOM refs ---
  const loginDiv = document.getElementById("login");
  const appDiv = document.getElementById("app");
  const passwordInput = document.getElementById("passwordInput");
  const loginBtn = document.getElementById("loginBtn");
  const newBtn = document.getElementById("newBtn");
  const datePicker = document.getElementById("datePicker");
  const goTodayBtn = document.getElementById("goTodayBtn");
  const entryText = document.getElementById("entryText");
  const saveBtn = document.getElementById("saveBtn");
  const changePassBtn = document.getElementById("changePassBtn");
  const renameBtn = document.getElementById("renameBtn");
  const diaryTitle = document.getElementById("diaryTitle");
  const selectedDateText = document.getElementById("selectedDateText");
  const editPermission = document.getElementById("editPermission");
  const bgInput = document.getElementById("bgInput");
  const bgSaveBtn = document.getElementById("bgSaveBtn");
  const bgClearBtn = document.getElementById("bgClearBtn");
  const themeToggle = document.getElementById("themeToggle");
  const sizeSelect = document.getElementById("sizeSelect");
  const fontSelect = document.getElementById("fontSelect");
  const toolbar = document.getElementById("toolbar");
  const btnBold = document.getElementById("btnBold");
  const btnItalic = document.getElementById("btnItalic");
  const btnUnderline = document.getElementById("btnUnderline");
  const btnHighlight = document.getElementById("btnHighlight");
  const textColorBtn = document.getElementById("textColorBtn");
  const textColorWrap = document.getElementById("textColorWrap");
  const textColorPopup = document.getElementById("textColorPopup");
  const bgColorPopup = document.getElementById("bgColorPopup");
  const bgColorBtn = document.getElementById("bgColorBtn");
  const status = document.getElementById("status");

  // palette colors
  const palette = ['#000000','#333333','#555555','#8B5CF6','#2563EB','#10B981','#F59E0B','#EF4444','#FFFFFF','#FFD3B6','#BDE0FE','#FFD6F0'];

  // create swatches
  function createPalette(el, onClick){
    el.innerHTML='';
    palette.forEach(c=>{
      const s = document.createElement('div');
      s.className='sw';
      s.style.background=c;
      s.title=c;
      s.onclick=()=> onClick(c);
      el.appendChild(s);
    });
  }
  createPalette(textColorPopup, (c)=> {
    applyStyleToSelection('color', c);
    textColorPopup.style.display='none';
    textColorBtn.classList.add('active');
  });
  createPalette(bgColorPopup, (c)=> {
    applyStyleToSelection('backgroundColor', c);
    bgColorPopup.style.display='none';
    btnHighlight.classList.add('active');
  });

  // simple toolbar toggles â€” these apply inline styles to selection by wrapping selected text with markers
  function wrapSelection(prefix, suffix){
    const el = entryText;
    const s = el.selectionStart, e = el.selectionEnd;
    if(s===e){
      // no selection: toggle marker at caret (simple)
      const value = el.value;
      el.value = value.slice(0,s) + prefix + suffix + value.slice(e);
      el.selectionStart = el.selectionEnd = s + prefix.length;
    } else {
      const value = el.value;
      el.value = value.slice(0,s) + prefix + value.slice(s,e) + suffix + value.slice(e);
      el.selectionStart = s; el.selectionEnd = e + prefix.length + suffix.length;
    }
    updateToolbarState();
  }

  function applyStyleToSelection(style, val){
    // we'll wrap selection with a JSON-like token for storage and later rendering: e.g. <<style|value>>text<</style>>
    // Format: âŸ¨âŸ¨fmt:{ "style":"color","value":"#fff"}âŸ©âŸ©selected textâŸ¨âŸ¨/fmtâŸ©âŸ©
    const el = entryText;
    const s = el.selectionStart, e = el.selectionEnd;
    const startToken = `âŸ¨âŸ¨fmt:${JSON.stringify({style, value:val})}âŸ©âŸ©`;
    const endToken = `âŸ¨âŸ¨/fmtâŸ©âŸ©`;
    if(s===e){
      el.value = el.value.slice(0,s) + startToken + endToken + el.value.slice(e);
      el.selectionStart = el.selectionEnd = s + startToken.length;
    } else {
      const value = el.value;
      el.value = value.slice(0,s) + startToken + value.slice(s,e) + endToken + value.slice(e);
      el.selectionStart = s; el.selectionEnd = e + startToken.length + endToken.length;
    }
  }

  function insertSimpleTag(tag){
    const map = { bold: ['**','**'], italic:['*','*'], underline:['__','__'] };
    const [pre,suf] = map[tag] || ['',''];
    wrapSelection(pre,suf);
  }

  btnBold.onclick = ()=> { insertSimpleTag('bold'); btnBold.classList.toggle('active'); };
  btnItalic.onclick = ()=> { insertSimpleTag('italic'); btnItalic.classList.toggle('active'); };
  btnUnderline.onclick = ()=> { insertSimpleTag('underline'); btnUnderline.classList.toggle('active'); };
  btnHighlight.onclick = ()=> { applyStyleToSelection('backgroundColor', '#fff59b'); btnHighlight.classList.add('active'); };

  textColorBtn.onclick = ()=> {
    textColorPopup.style.display = textColorPopup.style.display === 'none' ? 'grid' : 'none';
  };
  bgColorBtn.onclick = ()=> {
    bgColorPopup.style.display = bgColorPopup.style.display === 'none' ? 'grid' : 'none';
  };

  // font/size changes apply to whole entry visually (stored in settings)
  function applyFontAndSize(){
    entryText.style.fontFamily = fontSelect.value;
    entryText.style.fontSize = sizeSelect.value + 'px';
  }
  fontSelect.onchange = applyFontAndSize;
  sizeSelect.onchange = applyFontAndSize;

  // theme toggle
  themeToggle.onclick = ()=> {
    const body = document.body;
    const t = body.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
    body.setAttribute('data-theme', t);
    // store as setting for the current entry when saved
  };

  // today date
  function toYMD(d){ return d.toISOString().slice(0,10) }

  // basic helpers for Base64
  function bufToBase64(buf){ return btoa(String.fromCharCode(...new Uint8Array(buf))) }
  function base64ToBuf(b64){ return Uint8Array.from(atob(b64), c=>c.charCodeAt(0)) }

  // --- Web Crypto functions ---
  async function deriveKey(password, saltRaw){
    const enc = new TextEncoder();
    const pwKey = await crypto.subtle.importKey('raw', enc.encode(password), 'PBKDF2', false, ['deriveKey']);
    return crypto.subtle.deriveKey({
      name:'PBKDF2', salt: saltRaw, iterations: 150000, hash:'SHA-256'
    }, pwKey, { name:'AES-GCM', length:256 }, false, ['encrypt','decrypt']);
  }

  async function encryptPayload(password, payloadObj){
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const key = await deriveKey(password, salt);
    const enc = new TextEncoder();
    const data = enc.encode(JSON.stringify(payloadObj));
    const cipher = await crypto.subtle.encrypt({ name:'AES-GCM', iv }, key, data);
    return {
      cipher: bufToBase64(cipher),
      iv: bufToBase64(iv),
      salt: bufToBase64(salt)
    };
  }

  async function decryptPayload(password, docData){
    try {
      const iv = base64ToBuf(docData.iv);
      const salt = base64ToBuf(docData.salt);
      const key = await deriveKey(password, salt);
      const plainBuf = await crypto.subtle.decrypt({ name:'AES-GCM', iv }, key, base64ToBuf(docData.cipher));
      const dec = new TextDecoder();
      return JSON.parse(dec.decode(plainBuf));
    } catch(e){
      throw new Error('Decryption failed');
    }
  }

  // --- Application state ---
  let currentPassword = null;
  let diaryName = 'My Secret Diary';
  let currentDate = toYMD(new Date());
  let currentEntryMeta = { background: null, theme: 'light', font: 'Quicksand', size: 16 };

  // init UI
  function initUI(){
    loginDiv.style.display='block';
    appDiv.style.display='none';
    const today = new Date();
    datePicker.value = toYMD(today);
    selectedDateText.textContent = datePicker.value;
    document.getElementById('currentDateLabel').textContent = toYMD(today);
    applyFontAndSize();
    entryText.disabled = true;
    updateEditPermission();
  }

  function showApp(){
    loginDiv.style.display='none';
    appDiv.style.display='flex';
    applyFontAndSize();
    diaryTitle.textContent = diaryName;
    updateEditPermission();
  }

  function updateEditPermission(){
    const sel = datePicker.value;
    selectedDateText.textContent = sel;
    const selDate = new Date(sel + 'T00:00:00');
    const today = new Date();
    today.setHours(0,0,0,0);
    if(selDate > today){
      editPermission.textContent = 'Future â€” view only';
      entryText.readOnly = true;
      saveBtn.disabled = true;
    } else {
      editPermission.textContent = 'Editable';
      entryText.readOnly = false;
      saveBtn.disabled = false;
    }
  }

  goTodayBtn.onclick = ()=> { datePicker.value = toYMD(new Date()); datePicker.dispatchEvent(new Event('change')); };

  // load settings doc (settings stored encrypted at doc ID 'settings' for this diary)
  async function loadSettingsFromFirestore(){
    try {
      const settingsDoc = await getDoc(doc(db, 'entries', 'settings'));
      if(settingsDoc.exists()){
        try {
          const data = settingsDoc.data();
          // if encrypted (has cipher) we decrypt
          if(data.cipher && data.iv && data.salt){
            const payload = await decryptPayload(currentPassword, data);
            diaryName = payload.name || diaryName;
            currentEntryMeta = payload.meta || currentEntryMeta;
            diaryTitle.textContent = diaryName;
            // apply saved theme/font/size
            document.body.setAttribute('data-theme', currentEntryMeta.theme || 'light');
            fontSelect.value = currentEntryMeta.font || fontSelect.value;
            sizeSelect.value = currentEntryMeta.size || sizeSelect.value;
            applyFontAndSize();
          } else {
            // fallback if plain (old install)
            diaryName = data.name || diaryName;
            diaryTitle.textContent = diaryName;
          }
        } catch(e){ console.warn('Failed to decrypt settings (wrong password?)', e); }
      } else {
        // create settings encrypted
        const payload = { name: diaryName, meta: currentEntryMeta };
        const enc = await encryptPayload(currentPassword, payload);
        await setDoc(doc(db,'entries','settings'), enc);
      }
    } catch(e){ console.error(e) }
  }

  // load entry
  async function loadEntry(){
    const date = datePicker.value;
    status.textContent = 'Loading...';
    try {
      const entryDoc = await getDoc(doc(db, 'entries', date));
      if(entryDoc.exists()){
        const data = entryDoc.data();
        if(data.cipher && data.iv && data.salt){
          try {
            const payload = await decryptPayload(currentPassword, data);
            // payload: { text, meta: {background,theme,font,size} }
            entryText.value = payload.text || '';
            currentEntryMeta = payload.meta || currentEntryMeta;
            diaryTitle.textContent = payload.diaryName || diaryName;
            // apply meta
            if(currentEntryMeta.font) fontSelect.value = currentEntryMeta.font;
            if(currentEntryMeta.size) sizeSelect.value = currentEntryMeta.size;
            applyFontAndSize();
            if(currentEntryMeta.background){
              if(currentEntryMeta.background.startsWith('http')) document.body.style.backgroundImage = `url(${currentEntryMeta.background})`;
              else document.body.style.backgroundColor = currentEntryMeta.background;
            } else {
              document.body.style.backgroundImage = '';
              document.body.style.backgroundColor = '';
            }
            document.body.setAttribute('data-theme', currentEntryMeta.theme || 'light');
            status.textContent = 'Loaded (encrypted)';
          } catch(e){
            entryText.value = '';
            status.textContent = 'Unable to decrypt this entry (wrong password?)';
          }
        } else if(data.text){
          // legacy plaintext â€” show but warn
          entryText.value = data.text;
          status.textContent = 'Loaded (UNENCRYPTED legacy entry)';
        } else {
          entryText.value='';
          status.textContent='Empty';
        }
      } else {
        entryText.value='';
        status.textContent='No entry';
      }
    } catch(e){ console.error(e); status.textContent='Load error' }
    updateEditPermission();
  }

  datePicker.onchange = async ()=>{
    currentDate = datePicker.value;
    selectedDateText.textContent = currentDate;
    updateEditPermission();
    await loadEntry();
  };

  // save entry
  saveBtn.onclick = async ()=>{
    const date = datePicker.value;
    const selDate = new Date(date + 'T00:00:00');
    const today = new Date(); today.setHours(0,0,0,0);
    if(selDate > today){
      alert('Cannot save future entries.');
      return;
    }
    const payload = {
      text: entryText.value,
      diaryName,
      meta: {
        background: bgInput.value || currentEntryMeta.background,
        theme: document.body.getAttribute('data-theme') || 'light',
        font: fontSelect.value,
        size: sizeSelect.value
      },
      savedAt: new Date().toISOString()
    };
    status.textContent = 'Encrypting & saving...';
    try {
      const enc = await encryptPayload(currentPassword, payload);
      // add timestamp in plaintext fields only if you want (not recommended)
      await setDoc(doc(db,'entries', date), {...enc, savedAt: serverTimestamp()});
      status.textContent = 'Saved (encrypted)';
      alert('Saved!');
    } catch(e){ console.error(e); status.textContent='Save failed'; alert('Save failed'); }
  };

  // change password - this will re-encrypt settings with new password but *will not* re-encrypt all entries automatically.
  // (Re-encrypting all entries requires the old password to decrypt then re-encrypt with the new one; we offer to do that.)
  changePassBtn.onclick = async ()=>{
    const newPass = prompt('Enter new password (will re-encrypt settings). To re-encrypt all entries, check the next prompt.');
    if(!newPass) return;
    // re-encrypt settings
    currentPassword = newPass;
    // update settings doc
    const payload = { name: diaryName, meta: currentEntryMeta };
    const enc = await encryptPayload(currentPassword, payload);
    await setDoc(doc(db,'entries','settings'), enc);
    const reencryptAll = confirm('Do you want to re-encrypt all existing entries now? (This will attempt to load each date entry and re-encrypt it with new password. This may fail if you cannot decrypt them with old password.)');
    if(reencryptAll){
      // NOTE: we don't have a list of all dates; a full re-encrypt requires reading a list you maintain (index). For simplicity, we only re-encrypt currently loaded entry.
      // To fully re-encrypt all entries you must maintain an index listing keys (or export them).
      try {
        const date = datePicker.value;
        const entryDoc = await getDoc(doc(db,'entries',date));
        if(entryDoc.exists()){
          const data = entryDoc.data();
          // try to decrypt with old password - but we changed it already so this is a place where you might want to prompt for old password
          alert('Because we already overwrote the settings key, re-encrypting entries in-place inside the browser requires the old password. If you want full re-encryption you should export entries using the old password or re-run with the old password first.');
        }
      } catch(e){ console.error(e) }
    }
    alert('Password changed for settings. Note: existing entries remain encrypted with the previous password until you explicitly re-encrypt them.');
  };

  // rename diary
  renameBtn.onclick = async ()=>{
    const newName = prompt('Enter new diary name:');
    if(!newName) return;
    diaryName = newName;
    diaryTitle.textContent = diaryName;
    // re-save settings encrypted
    const payload = { name: diaryName, meta: currentEntryMeta };
    const enc = await encryptPayload(currentPassword, payload);
    await setDoc(doc(db,'entries','settings'), enc);
    alert('Diary renamed.');
  };

  // background apply/clear
  bgSaveBtn.onclick = ()=> {
    currentEntryMeta.background = bgInput.value || null;
    if(currentEntryMeta.background && currentEntryMeta.background.startsWith('http')) document.body.style.backgroundImage = `url(${currentEntryMeta.background})`;
    else { document.body.style.backgroundImage=''; document.body.style.backgroundColor = currentEntryMeta.background || ''; }
    alert('Background applied locally. It will be saved when you press Save Entry.');
  };
  bgClearBtn.onclick = ()=> {
    bgInput.value=''; currentEntryMeta.background = null; document.body.style.backgroundImage=''; document.body.style.backgroundColor='';
    alert('Background cleared locally. Save to persist.');
  };

  // login flow
  loginBtn.onclick = async ()=>{
    const pw = passwordInput.value;
    if(!pw){ alert('Enter password'); return; }
    currentPassword = pw;
    // load settings and entries
    await loadSettingsFromFirestore();
    showApp();
    await loadEntry();
  };
  newBtn.onclick = async ()=>{
    const pw = prompt('Set a new diary password (this will be used to encrypt your diary).');
    if(!pw){ alert('Password required'); return; }
    currentPassword = pw;
    // create encrypted settings
    const payload = { name: diaryName, meta: currentEntryMeta };
    const enc = await encryptPayload(currentPassword, payload);
    await setDoc(doc(db,'entries','settings'), enc);
    alert('Diary created and settings saved encrypted.');
    showApp();
    await loadEntry();
  };

  // initial
  initUI();
  // show login by default
  loginDiv.style.display='block';

  // small UX: close popups on outside click
  document.addEventListener('click', (e)=>{
    if(!textColorWrap.contains(e.target)) textColorPopup.style.display='none';
    if(!bgColorBtn.contains(e.target)) bgColorPopup.style.display='none';
  });

  // helper to show toolbar state (very basic)
  function updateToolbarState(){
    // scanning selection for markers is complex; skip heavy detection for now
  }
  </script>
</body>
</html>
